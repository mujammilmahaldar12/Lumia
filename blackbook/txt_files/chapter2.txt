CHAPTER 2
SURVEY OF TECHNOLOGIES

---

2.1 Technology Overview

The LUMIA Investment Management System is built on a modern technology stack carefully selected to ensure scalability, performance, maintainability, and ease of development. This chapter provides a comprehensive survey of the technologies, frameworks, libraries, algorithms, and methodologies employed in the system.

---

2.1.1 Programming Language and Runtime Environment

Python 3.10+

Python serves as the primary programming language for the LUMIA system. The selection of Python is justified by several compelling factors:

Technical Advantages:
- Rich Ecosystem: Extensive libraries for data analysis (NumPy, Pandas), financial computing (QuantLib), machine learning (Scikit-learn), and web development (Streamlit)
- Rapid Development: High-level abstractions and dynamic typing enable faster prototyping and iteration
- Cross-Platform Compatibility: Runs seamlessly on Windows, Linux, and macOS
- Strong Community Support: Large developer community with extensive documentation and resources
- Performance: When combined with optimized libraries (NumPy uses C/Fortran backends), Python achieves near-native performance for numerical computations

Domain Suitability:
- De facto standard in financial technology and quantitative finance
- Preferred language for data science and machine learning applications
- Excellent support for statistical analysis and financial modeling

Version Selection:
Python 3.10 was chosen for:
- Structural Pattern Matching: Enhances code readability in complex conditional logic
- Type Hinting Improvements: Better static type checking with union operators
- Performance Enhancements: 10-15% faster than Python 3.9 for specific operations
- Security Updates: Long-term support with regular security patches

---

2.1.2 Database Management System

PostgreSQL 14.x

PostgreSQL is employed as the primary relational database management system for LUMIA.

Key Features Utilized:

1. ACID Compliance
- Atomicity, Consistency, Isolation, Durability guarantees
- Critical for financial data integrity
- Ensures transaction safety in concurrent operations

2. Advanced Indexing
- B-tree indexes for primary key lookups
- Composite indexes for multi-column queries
- Partial indexes for filtered data access
- GiST indexes for complex data types

3. Query Optimization
- Cost-based query planner
- Parallel query execution (leveraging multi-core processors)
- Query caching and prepared statements

4. JSONB Data Type
- Stores flexible metadata and configuration
- Binary JSON format for fast processing
- Indexable for efficient querying

5. Concurrency Control
- Multi-Version Concurrency Control (MVCC)
- Handles thousands of concurrent read/write operations
- No read locks blocking write operations

Database Size and Performance:
- Current database: 16,344 assets, 6.9M daily prices
- Query response time: <200ms for 95% of operations
- Storage: ~2.5 GB with indexes
- Backup frequency: Daily incremental, weekly full

Alternative Considered:
- MySQL: Rejected due to inferior JSON support and less sophisticated query optimizer
- MongoDB: Rejected due to lack of ACID guarantees and complex joins
- SQLite: Rejected due to limited concurrency and scalability

---

2.1.3 Object-Relational Mapping (ORM)

SQLAlchemy 2.0

SQLAlchemy provides the database abstraction layer, enabling Python objects to map to database tables.

Core Features:

1. Declarative Base Models


2. Relationship Management
- One-to-many: Asset → DailyPrices
- Many-to-many: Assets ↔ Sectors (via association tables)
- Lazy/eager loading strategies for performance optimization

3. Query Construction
- Pythonic query API avoiding raw SQL
- Type-safe operations with IDE autocomplete support
- Protection against SQL injection attacks

4. Connection Pooling
- Reuses database connections reducing overhead
- Configurable pool size (default: 10 connections)
- Automatic connection recycling

5. Migration Support
- Alembic integration for schema versioning
- Automated migration generation
- Rollback capabilities for safe deployments

Benefits:
- Database-agnostic code (easy migration between PostgreSQL, MySQL, etc.)
- Automatic query optimization through lazy loading
- Transaction management with context managers
- Prevents SQL injection through parameterized queries

---

2.1.4 Web Framework and User Interface

Streamlit 1.28+

Streamlit is a Python framework for rapidly building interactive web applications.

Key Advantages:

1. Rapid Development
- Pure Python (no HTML/CSS/JavaScript required)
- Hot reloading during development
- Built-in caching mechanisms

2. Interactive Widgets
- Number inputs, sliders, selectboxes for user configuration
- Buttons for portfolio generation
- Text inputs for AI chat interface
- File uploaders for data import

3. Data Visualization Integration
- Native support for Plotly, Matplotlib, Altair
- DataFrame rendering with sorting and filtering
- Custom HTML/CSS injection for advanced styling

4. Session State Management
- Persistent state across user interactions
- Stores portfolio data, chat history
- Enables multi-page applications

5. Deployment
- Single-command deployment (streamlit run app.py)
- Built-in WebSocket for real-time updates
- Compatible with cloud platforms (AWS, GCP, Azure)

Custom Components:
- components.py: Reusable UI elements (metric cards, charts, chat messages)
- styles.py: Centralized CSS styling with Times New Roman font
- Component-based architecture for maintainability

Alternative Considered:
- Flask/Django: Rejected due to complexity and longer development time
- Dash: Considered but Streamlit offered faster prototyping
- React: Rejected to maintain pure Python stack

---

2.1.5 Data Visualization

Plotly 5.x

Plotly is used for creating interactive, publication-quality charts and graphs.

Chart Types Implemented:

1. Donut Chart (Pie with Hole)
- Displays asset allocation percentages
- Interactive tooltips showing amounts
- Color-coded by asset type

2. Bar Chart
- Compares number of holdings by asset type
- Horizontal/vertical orientation support
- Custom colors for visual distinction

3. Gauge Charts
- Expected return gauge (0-30% range)
- Risk/volatility gauge (0-40% range)
- Sharpe ratio gauge (0-3 range)
- Color zones: green (good), yellow (moderate), red (high)

4. Box Plot
- Score distribution across assets
- Identifies outliers and quartiles
- Grouped by asset type

Features Utilized:
- Responsive Design: Charts adapt to screen size
- Export Functionality: PNG, SVG, PDF download
- Zoom/Pan: Interactive exploration
- Hover Tooltips: Detailed information on hover
- Animation: Smooth transitions between states

Configuration:

---

2.1.6 Financial Data and APIs

Data Sources:

1. Yahoo Finance API (yfinance 0.2+)
- Purpose: Historical and real-time stock/ETF prices
- Data Retrieved: OHLCV (Open, High, Low, Close, Volume), dividends, splits
- Coverage: 50,000+ global equities and ETFs
- Frequency: Daily price updates
- Advantages: Free, no API key required, comprehensive coverage
- Limitations: Rate limiting (2000 requests/hour), occasional data gaps

2. NewsAPI
- Purpose: Financial news collection for sentiment analysis
- Coverage: 80,000+ global news sources
- Query: Keyword-based searches (company names, sectors)
- Data Retrieved: Headlines, descriptions, publication dates, sources
- API Key: Required (free tier: 100 requests/day)
- Usage: News sentiment influences 15% of asset scores

3. CoinGecko API
- Purpose: Cryptocurrency price data
- Coverage: 10,000+ cryptocurrencies
- Data Retrieved: Prices, market cap, volume, 24h changes
- Frequency: Real-time updates (5-minute intervals)
- Advantages: Free tier sufficient for LUMIA needs
- Rate Limit: 50 calls/minute (free tier)

4. Manual Data Sources
- Indian Mutual Funds: Web scraping from AMFI website
- Fundamental Data: Curated from financial statements
- Bond Data: Government securities database (future integration)

API Integration Architecture:
- Retry logic with exponential backoff
- Request caching to minimize API calls
- Error handling for missing/malformed data
- Asynchronous requests for parallel processing

---

2.1.7 Core Python Libraries

Data Processing and Analysis:

1. NumPy 1.24+
- Numerical computing with multidimensional arrays
- Linear algebra operations (matrix multiplication, eigenvalues)
- Statistical functions (mean, std, correlation)
- Performance: C-optimized, 10-100x faster than pure Python

2. Pandas 2.0+
- DataFrames for tabular data manipulation
- Time series analysis with datetime indexes
- GroupBy operations for aggregations
- Missing data handling (fillna, dropna)
- CSV/JSON/SQL reading and writing

3. SciPy 1.11+
- Optimization algorithms (minimize, curve fitting)
- Used in portfolio optimization
- Statistical tests and distributions
- Sparse matrix operations

Financial Computing:

4. QuantLib-Python
- Bond pricing and yield calculations
- Option pricing models (Black-Scholes)
- Interest rate curve construction
- Risk metrics computation

Machine Learning (Future Enhancements):

5. Scikit-learn 1.3+
- Classification and regression models
- Clustering for asset grouping
- Dimensionality reduction (PCA)
- Model evaluation metrics

6. TensorFlow/PyTorch (Planned)
- Deep learning for price prediction
- LSTM networks for time series forecasting
- Reinforcement learning for dynamic rebalancing

Utilities:

7. Requests 2.31+
- HTTP library for API calls
- Session management for persistent connections
- Automatic retry with timeout handling

8. BeautifulSoup4 4.12+
- HTML parsing for web scraping
- Used in mutual fund data collection
- CSS selector support

9. python-dotenv 1.0+
- Environment variable management
- Secure API key storage
- Configuration management

---

2.1.8 Portfolio Optimization Algorithms

Modern Portfolio Theory (MPT)

Developed by Harry Markowitz (1952), MPT forms the foundation of LUMIA's optimization engine.

Key Concepts:

1. Expected Return


2. Portfolio Variance (Risk)


3. Sharpe Ratio (Risk-Adjusted Return)


Optimization Problem:

Solver: SciPy SLSQP (Sequential Least Squares Programming)
- Gradient-based optimization
- Handles equality and inequality constraints
- Converges in <100 iterations for typical portfolios
- Fallback to equal-weight if optimization fails

Alternative Approaches Evaluated:

1. Black-Litterman Model
- Incorporates investor views
- More stable than pure MPT
- Complexity not justified for LUMIA's use case

2. Risk Parity
- Equal risk contribution from each asset
- Good for diversification but may sacrifice returns
- Considered for future "balanced" strategy

3. Minimum Variance Portfolio
- Minimizes risk regardless of return
- Too conservative for most users
- Available as optional strategy

---

2.1.9 Asset Scoring Methodology

LUMIA employs a proprietary 100-point scoring system combining four dimensions:

1. Fundamental Score (30 points max)

Evaluates financial health using key ratios:
- Profitability: ROE, ROA, Profit Margin (10 points)
- Growth: Revenue Growth, EPS Growth (8 points)
- Financial Stability: Debt-to-Equity, Current Ratio (7 points)
- Valuation: P/E Ratio, P/B Ratio (5 points)

2. Technical Score (40 points max)

Analyzes price trends and momentum:
- Moving Averages: 20-day, 50-day, 200-day crossovers (12 points)
- Momentum Indicators: RSI, MACD, Stochastic (12 points)
- Trend Strength: ADX, Directional Indicators (8 points)
- Volume Analysis: On-Balance Volume, Volume Trends (8 points)

3. Sentiment Score (15 points max)

Gauges market sentiment:
- News Sentiment: Positive/negative news count and tone (10 points)
- Social Media: Twitter mentions, Reddit discussions (5 points, future)
- Analyst Ratings: Buy/hold/sell recommendations (future enhancement)

4. Advanced Metrics Bonus (15 points max)

Rewards superior risk-adjusted performance:
- Sharpe Ratio > 1.0: +5 points
- Maximum Drawdown < 20%: +3 points
- CAGR > 15%: +4 points
- Sortino Ratio > 1.5: +3 points

Normalization:
- Each metric scaled to [0, 1] using percentile ranking
- Outliers capped at 99th percentile
- Missing data defaults to median score

Validation:
- Backtested correlation: 0.78 with 1-year forward returns
- Top quartile (score ≥ 70) outperformed bottom quartile by 18% annually

---

2.1.10 Artificial Intelligence and Chat System

Lumia AI Chat Assistant

A custom-built intelligent assistant providing portfolio insights.

Architecture:

1. Natural Language Understanding
- Keyword-based intent classification
- Pattern matching for question types (allocation, risk, returns, best asset)
- Context-aware responses based on conversation history

2. Response Generation
- Template-based with dynamic data injection
- Markdown formatting for structured output
- Personalized to user's portfolio composition

3. Capabilities
- Explains allocation strategy with percentages
- Recommends best assets with score breakdowns
- Projects returns year-by-year
- Analyzes risk profile and volatility
- Compares assets across dimensions
- Explains diversification benefits

4. Future Enhancements
- GPT Integration: OpenAI API for more natural conversations
- FinBERT: Fine-tuned BERT model for financial text understanding
- RAG (Retrieval-Augmented Generation): Query knowledge base for accurate responses
- Voice Interface: Speech-to-text for hands-free interaction

Current Implementation:
- Rule-based system with 9 intent categories
- 90%+ accuracy for common queries
- Average response time: <500ms
- Maintains conversation history for context

---

2.1.11 Version Control and Collaboration

Git and GitHub

- Version Control: Git for distributed version control
- Repository: GitHub for remote hosting and collaboration
- Branching Strategy:
- main branch: stable production code
- dev branch: active development
- Feature branches: feature/ai-chat, feature/crypto-support
- Commit Conventions: Semantic commit messages (feat, fix, docs, refactor)
- Code Review: Pull requests with automated checks
- CI/CD: GitHub Actions for automated testing (future)

---

2.1.12 Development Tools and Environment

Integrated Development Environment (IDE):
- Visual Studio Code: Primary IDE
- Python extension for IntelliSense
- SQLAlchemy extension for ORM support
- Markdown preview for documentation
- Git integration for version control

Package Management:
- pip: Python package installer
- requirements.txt: Dependency specification
- Virtual Environment (venv): Isolated Python environments

Database Tools:
- pgAdmin 4: PostgreSQL administration and query tool
- DBeaver: Universal database management tool
- Alembic: Database migration management

Testing Tools:
- pytest: Unit and integration testing framework
- coverage.py: Code coverage measurement
- Postman: API testing and documentation

Logging and Monitoring:
- Python logging module: Structured logging
- Log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
- Log rotation: Daily rotation with 7-day retention

---

2.1.13 Justification of Technology Choices

The technology stack for LUMIA was selected based on rigorous evaluation across multiple criteria:

Evaluation Criteria:
1. Performance: Sub-second response times, handles 100K+ assets
2. Scalability: Linear scaling with user count and data volume
3. Maintainability: Modular architecture, clean code principles
4. Cost: Primarily open-source, minimal licensing fees
5. Community: Active communities for troubleshooting and learning
6. Learning Curve: Reasonable learning curve for team members
7. Future-Proofing: Technologies with long-term support and evolution

Decision Matrix:

| Technology | Performance | Scalability | Cost | Community | Selected |
|------------|-------------|-------------|------|-----------|----------|
| Python | High | High | Free | Excellent | ✅ Yes |
| PostgreSQL | Excellent | High | Free | Excellent | ✅ Yes |
| MongoDB | High | Excellent | Free | Good | ❌ No (ACID) |
| React | High | High | Free | Excellent | ❌ No (complexity) |
| Streamlit | Good | Medium | Free | Growing | ✅ Yes (speed) |
| Django | Medium | High | Free | Excellent | ❌ No (overkill) |

Result:
The selected stack provides optimal balance between development speed, performance, and maintainability for LUMIA's requirements.

---

Page 9-12